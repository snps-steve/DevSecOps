# WebGoat Build, Security Scan, and Deployment Pipeline
# 
# Purpose: DevSecOps training demonstration showing comprehensive security scanning integration
# Architecture: 5-Stage Pipeline (Build → Container → Security → Deploy → Validate)
# Integration: Bridge CLI Direct Integration (CLI Switches) - NO Security Scan Task Extension
#
# Security Scans: 
# • SCA: package manager, signature, BDSC (Black Duck Secure Container) scanning via Bridge CLI
# • SAST: Coverity security vulnerability detection and code quality analysis via Bridge CLI
# • Coverage: Both PR and non-PR scans with full SARIF reporting
#
# Results appear in: Extensions tab, Tests tab, Pipeline artifacts, PR comments
# Gating: No build failures on security findings - builds succeed but marked "succeeded with issues"
#

trigger:
  branches:
    include:
    - main
    - develop
variables:
- group: blackduck-sca-variables
- group: coverity-variables
- name: PROJECT_NAME
  value: $(Build.Repository.Name)
- name: PROJECT_VERSION
  value: $(Build.SourceBranchName)
- name: K8S_SERVER_IP
  value: "172.31.17.121"
- name: K8S_PUBLIC_IP
  value: "44.253.226.227"
- name: WEBGOAT_NODEPORT
  value: "30080"
- name: WEBWOLF_NODEPORT
  value: "30090"
- name: COVERITY_VIEW
  value: 'Outstanding Issues'

stages:
- stage: BuildWebGoat
  displayName: 'Stage 1: Build WebGoat'
  jobs:
  - job: BuildJob
    displayName: 'Build WebGoat Source Code'
    pool:
      name: 'Self-Hosted ADO Agent'
    steps:
    - task: CmdLine@2
      displayName: 'Verify Java 23 Environment'
      inputs:
        script: |
          set -ex
          echo "=== Java Environment Check ==="
          java -version
          javac -version
          echo "JAVA_HOME: $JAVA_HOME"
          ./mvnw -v
    - task: CmdLine@2
      displayName: 'Build WebGoat with Java 23'
      inputs:
        script: |
          set -ex
          echo "Building WebGoat from source with Java 23..."
          chmod +x ./mvnw
          ./mvnw clean install -DskipTests
          echo "=== Build artifacts ==="
          find . -name "webgoat-*.jar" -not -path "*/original/*" -ls
    - task: PublishPipelineArtifact@1
      displayName: 'Publish WebGoat Source and JAR'
      inputs:
        targetPath: '$(Build.SourcesDirectory)'
        artifact: 'WebGoatSource'

- stage: BuildContainer
  displayName: 'Stage 2: Build/Verify Container'
  dependsOn:
  - BuildWebGoat
  jobs:
  - job: ContainerBuildJob
    displayName: 'Build and Verify WebGoat Container'
    pool:
      name: 'Self-Hosted ADO Agent'
    steps:
    - task: DownloadPipelineArtifact@2
      displayName: 'Download WebGoat Source'
      inputs:
        artifact: 'WebGoatSource'
        path: '$(Build.SourcesDirectory)'
    - task: CmdLine@2
      displayName: 'Create WebGoat Dockerfile'
      inputs:
        script: |
          echo "Creating WebGoat Dockerfile..."
          JAR_FILE=$(find . -name "webgoat-*.jar" -not -path "*/original/*" | head -1)
          if [ -z "$JAR_FILE" ]; then
              echo "ERROR: No WebGoat JAR file found!"
              echo "Available JAR files:"
              find . -name "*.jar" -type f
              exit 1
          fi
          echo "Found JAR file: $JAR_FILE"

          cat > Dockerfile << 'EOF'
          FROM docker.io/eclipse-temurin:23-jdk-noble
          LABEL name="WebGoat: A deliberately insecure Web Application"
          LABEL maintainer="WebGoat team"
          LABEL version="BUILD_ID_PLACEHOLDER"
          RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*
          RUN useradd -ms /bin/bash webgoat && chgrp -R 0 /home/webgoat && chmod -R g=u /home/webgoat
          RUN mkdir -p /home/webgoat/.webgoat-2025.4-SNAPSHOT && chown -R webgoat:webgoat /home/webgoat
          USER webgoat
          COPY --chown=webgoat JAR_FILE_PLACEHOLDER /home/webgoat/webgoat.jar
          EXPOSE 8080
          EXPOSE 9090
          ENV TZ=Europe/Amsterdam
          WORKDIR /home/webgoat
          ENTRYPOINT [ "java", \
             "-Duser.home=/home/webgoat", \
             "-Dfile.encoding=UTF-8", \
             "--add-opens", "java.base/java.lang=ALL-UNNAMED", \
             "--add-opens", "java.base/java.util=ALL-UNNAMED", \
             "--add-opens", "java.base/java.lang.reflect=ALL-UNNAMED", \
             "--add-opens", "java.base/java.text=ALL-UNNAMED", \
             "--add-opens", "java.desktop/java.beans=ALL-UNNAMED", \
             "--add-opens", "java.desktop/java.awt.font=ALL-UNNAMED", \
             "--add-opens", "java.base/sun.nio.ch=ALL-UNNAMED", \
             "--add-opens", "java.base/java.io=ALL-UNNAMED", \
             "-Drunning.in.docker=true", \
             "-jar", "webgoat.jar" ]
          HEALTHCHECK --interval=10s --timeout=5s --start-period=60s --retries=5 \
             CMD curl --fail --silent http://localhost:8080/WebGoat/actuator/health || exit 1
          EOF

          sed -i "s|JAR_FILE_PLACEHOLDER|$JAR_FILE|g" Dockerfile
          sed -i "s|BUILD_ID_PLACEHOLDER|$(Build.BuildId)|g" Dockerfile
          echo "=== Created Dockerfile ==="
          cat Dockerfile
    - task: Docker@2
      displayName: 'Build WebGoat Docker Image'
      inputs:
        command: 'build'
        dockerfile: 'Dockerfile'
        repository: 'webgoat'
        tags: |
          $(Build.BuildId)
          latest
    - task: CmdLine@2
      displayName: 'Verify and Save Docker Image'
      inputs:
        script: |
          echo "=== Docker Image Verification ==="
          docker images | grep webgoat
          IMAGE_TAG="webgoat:$(Build.BuildId)"
          if docker images | grep -q "webgoat.*$(Build.BuildId)"; then
              echo "SUCCESS: Found $IMAGE_TAG"
          else
              echo "ERROR: $IMAGE_TAG not found!"
              exit 1
          fi
          
          # Save image as tar for deployment
          TAR_FILE="webgoat-$(Build.BuildId).tar"
          echo "Saving Docker image to tar file..."
          docker save ${IMAGE_TAG} -o ${TAR_FILE}
          if [ -f "${TAR_FILE}" ]; then
              TAR_SIZE=$(du -h ${TAR_FILE} | cut -f1)
              echo "SUCCESS: Created ${TAR_FILE} (${TAR_SIZE})"
          else
              echo "ERROR: Failed to create tar file"
              exit 1
          fi
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Container Image'
      inputs:
        targetPath: 'webgoat-$(Build.BuildId).tar'
        artifact: 'WebGoatContainerImage'

- stage: SecurityScans
  displayName: 'Stage 3: Execute Security Scans (Bridge CLI)'
  dependsOn:
  - BuildWebGoat
  - BuildContainer
  jobs:
  - job: BlackDuckSourceScan
    displayName: 'Bridge CLI: Black Duck SCA Source Analysis'
    pool:
      name: 'Self-Hosted ADO Agent'
    steps:
    - task: DownloadPipelineArtifact@2
      displayName: 'Download WebGoat Source'
      inputs:
        artifact: 'WebGoatSource'
        path: '$(Build.SourcesDirectory)'
    - bash: |
        set -ex
        curl -fLsS -o bridge.zip $BRIDGECLI_LINUX64 && unzip -qo -d $(Agent.TempDirectory) bridge.zip && rm -f bridge.zip
        $(Agent.TempDirectory)/bridge-cli-bundle-linux64/bridge-cli --stage blackducksca
      env:
        BRIDGE_BLACKDUCKSCA_URL: $(BLACKDUCK_URL)
        BRIDGE_BLACKDUCKSCA_TOKEN: $(BLACKDUCK_API_TOKEN)
        BRIDGE_BLACKDUCKSCA_SCAN_FULL: true
        BRIDGE_BLACKDUCKSCA_SCAN_FAILURE_SEVERITIES: 'BLOCKER,CRITICAL'
        BRIDGE_BLACKDUCKSCA_FIXPR_ENABLED: true
        BRIDGE_BLACKDUCKSCA_REPORTS_SARIF_CREATE: true
        BRIDGE_AZURE_USER_TOKEN: $(System.AccessToken)
        BRIDGE_AZURE_ORGANIZATION_NAME: $(System.TeamFoundationCollectionUri)
        BRIDGE_AZURE_REPOSITORY_NAME: $(Build.Repository.Name)
        BRIDGE_AZURE_PROJECT_NAME: $(System.TeamProject)
        BRIDGE_AZURE_REPOSITORY_BRANCH_NAME: $(Build.SourceBranchName)
        DETECT_PROJECT_NAME: $(Build.Repository.Name)
        DETECT_PROJECT_VERSION_NAME: $(Build.SourceBranchName)
        DETECT_CODE_LOCATION_NAME: $(Build.Repository.Name)-$(Build.SourceBranchName)
      displayName: 'Black Duck Full Scan'
      condition: not(eq(variables['Build.Reason'], 'PullRequest'))
      continueOnError: true
    - bash: |
        set -ex
        curl -fLsS -o bridge.zip $BRIDGECLI_LINUX64 && unzip -qo -d $(Agent.TempDirectory) bridge.zip && rm -f bridge.zip
        $(Agent.TempDirectory)/bridge-cli-bundle-linux64/bridge-cli --stage blackducksca
      env:
        BRIDGE_BLACKDUCKSCA_URL: $(BLACKDUCK_URL)
        BRIDGE_BLACKDUCKSCA_TOKEN: $(BLACKDUCK_API_TOKEN)
        BRIDGE_BLACKDUCKSCA_SCAN_FULL: false
        BRIDGE_BLACKDUCKSCA_AUTOMATION_PRCOMMENT: true
        BRIDGE_AZURE_USER_TOKEN: $(System.AccessToken)
        BRIDGE_AZURE_ORGANIZATION_NAME: $(System.TeamFoundationCollectionUri)
        BRIDGE_AZURE_REPOSITORY_NAME: $(Build.Repository.Name)
        BRIDGE_AZURE_PROJECT_NAME: $(System.TeamProject)
        BRIDGE_AZURE_REPOSITORY_BRANCH_NAME: $(System.PullRequest.SourceBranch)
        BRIDGE_AZURE_REPOSITORY_PULL_NUMBER: $(System.PullRequest.PullRequestId)
        DETECT_PROJECT_NAME: $(Build.Repository.Name)
        DETECT_PROJECT_VERSION_NAME: $(System.PullRequest.targetBranchName)
        DETECT_CODE_LOCATION_NAME: $(Build.Repository.Name)-$(System.PullRequest.targetBranchName)
      displayName: 'Black Duck PR Scan'
      condition: eq(variables['Build.Reason'], 'PullRequest')
      continueOnError: true

  - job: BlackDuckContainerScan
    displayName: 'Bridge CLI: Black Duck Container Analysis'
    pool:
      name: 'Self-Hosted ADO Agent'
    steps:
    - task: DownloadPipelineArtifact@2
      displayName: 'Download WebGoat Container Image'
      inputs:
        artifact: 'WebGoatContainerImage'
        path: '$(Build.SourcesDirectory)'
    - bash: |
        set -ex
        # Verify container image exists
        TAR_FILE="webgoat-$(Build.BuildId).tar"
        if [ ! -f "${TAR_FILE}" ]; then
            echo "ERROR: Container image tar file not found: ${TAR_FILE}"
            exit 1
        fi
        
        # Load image for scanning
        docker load -i ${TAR_FILE}
        
        curl -fLsS -o bridge.zip $BRIDGECLI_LINUX64 && unzip -qo -d $(Agent.TempDirectory) bridge.zip && rm -f bridge.zip
        $(Agent.TempDirectory)/bridge-cli-bundle-linux64/bridge-cli --stage blackducksca
      env:
        BRIDGE_BLACKDUCKSCA_URL: $(BLACKDUCK_URL)
        BRIDGE_BLACKDUCKSCA_TOKEN: $(BLACKDUCK_API_TOKEN)
        BRIDGE_BLACKDUCKSCA_SCAN_FULL: true
        BRIDGE_BLACKDUCKSCA_SCAN_FAILURE_SEVERITIES: 'BLOCKER,CRITICAL'
        BRIDGE_BLACKDUCKSCA_REPORTS_SARIF_CREATE: true
        DETECT_PROJECT_NAME: $(Build.Repository.Name)
        DETECT_PROJECT_VERSION_NAME: $(Build.SourceBranchName)-container
        DETECT_CODE_LOCATION_NAME: $(Build.Repository.Name)-$(Build.SourceBranchName)-container
        DETECT_DOCKER_IMAGE: webgoat:$(Build.BuildId)
      displayName: 'Black Duck Container Scan'
      continueOnError: true

  - job: CoveritySAST
    displayName: 'Bridge CLI: Coverity SAST Analysis'
    pool:
      name: 'Self-Hosted ADO Agent'
    steps:
    - task: DownloadPipelineArtifact@2
      displayName: 'Download WebGoat Source'
      inputs:
        artifact: 'WebGoatSource'
        path: '$(Build.SourcesDirectory)'
    - bash: |
        set -ex
        curl -fLsS -o bridge.zip $BRIDGECLI_LINUX64 && unzip -qo -d $(Agent.TempDirectory) bridge.zip && rm -f bridge.zip
        $(Agent.TempDirectory)/bridge-cli-bundle-linux64/bridge-cli --stage connect
      env:
        BRIDGE_COVERITY_CONNECT_URL: $(COVERITY_URL)
        BRIDGE_COVERITY_CONNECT_USER_NAME: $(COV_USER)
        BRIDGE_COVERITY_CONNECT_USER_PASSWORD: $(COVERITY_PASSPHRASE)
        BRIDGE_COVERITY_CONNECT_PROJECT_NAME: $(Build.Repository.Name)
        BRIDGE_COVERITY_CONNECT_STREAM_NAME: $(Build.Repository.Name)-$(Build.SourceBranchName)
        BRIDGE_COVERITY_CONNECT_POLICY_VIEW: $(COVERITY_VIEW)
      displayName: 'Coverity Full Scan'
      condition: not(eq(variables['Build.Reason'], 'PullRequest'))
      continueOnError: true
    - bash: |
        set -ex
        curl -fLsS -o bridge.zip $BRIDGECLI_LINUX64 && unzip -qo -d $(Agent.TempDirectory) bridge.zip && rm -f bridge.zip
        $(Agent.TempDirectory)/bridge-cli-bundle-linux64/bridge-cli --stage connect
      env:
        BRIDGE_COVERITY_CONNECT_URL: $(COVERITY_URL)
        BRIDGE_COVERITY_CONNECT_USER_NAME: $(COV_USER)
        BRIDGE_COVERITY_CONNECT_USER_PASSWORD: $(COVERITY_PASSPHRASE)
        BRIDGE_COVERITY_CONNECT_PROJECT_NAME: $(Build.Repository.Name)
        BRIDGE_COVERITY_CONNECT_STREAM_NAME: $(Build.Repository.Name)-$(System.PullRequest.targetBranchName)
        BRIDGE_COVERITY_AUTOMATION_PRCOMMENT: true
        BRIDGE_AZURE_USER_TOKEN: $(System.AccessToken)
        BRIDGE_AZURE_ORGANIZATION_NAME: $(System.TeamFoundationCollectionUri)
        BRIDGE_AZURE_REPOSITORY_NAME: $(Build.Repository.Name)
        BRIDGE_AZURE_PROJECT_NAME: $(System.TeamProject)
        BRIDGE_AZURE_REPOSITORY_BRANCH_NAME: $(System.PullRequest.SourceBranch)
        BRIDGE_AZURE_REPOSITORY_PULL_NUMBER: $(System.PullRequest.PullRequestId)
      displayName: 'Coverity PR Scan'
      condition: eq(variables['Build.Reason'], 'PullRequest')
      continueOnError: true

  - job: PublishSecurityResults
    displayName: 'Publish Security Scan Results'
    dependsOn:
    - BlackDuckSourceScan
    - BlackDuckContainerScan
    - CoveritySAST
    condition: always()
    pool:
      name: 'Self-Hosted ADO Agent'
    steps:
    - task: PublishTestResults@2
      displayName: 'Publish SARIF Results'
      condition: always()
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '**/*.sarif'
        searchFolder: '$(Agent.WorkFolder)'
        publishRunAttachments: true
        failTaskOnFailedTests: false
        testRunTitle: 'Security Scan Results'
      continueOnError: true

- stage: DeployKubernetes
  displayName: 'Stage 4: Deploy via Kubernetes'
  dependsOn:
  - BuildContainer
  - SecurityScans
  condition: succeededOrFailed()
  jobs:
  - job: KubernetesDeployment
    displayName: 'Deploy WebGoat to Kubernetes'
    pool:
      name: 'Self-Hosted ADO Agent'
    steps:
    - task: DownloadSecureFile@1
      displayName: 'Download SSH Key'
      name: sshkey
      inputs:
        secureFile: 'steve-pem'
    - task: DownloadPipelineArtifact@2
      displayName: 'Download Container Image'
      inputs:
        artifact: 'WebGoatContainerImage'
        path: '$(Build.SourcesDirectory)'
    - task: CmdLine@2
      displayName: 'Transfer Image to Kubernetes'
      inputs:
        script: |
          set -e
          TAR_FILE="webgoat-$(Build.BuildId).tar"
          echo "=== Setting up SSH and transferring image ==="
          cp $(sshkey.secureFilePath) steve.pem
          chmod 400 steve.pem

          if [ ! -f "${TAR_FILE}" ]; then
              echo "ERROR: Container image tar file not found: ${TAR_FILE}"
              exit 1
          fi

          echo "Transferring ${TAR_FILE} to Kubernetes server..."
          scp -o StrictHostKeyChecking=no -i steve.pem ${TAR_FILE} ubuntu@$(K8S_SERVER_IP):/tmp/

          echo "Loading image on Kubernetes server..."
          ssh -o StrictHostKeyChecking=no -i steve.pem ubuntu@$(K8S_SERVER_IP) "
            sudo microk8s ctr image import /tmp/${TAR_FILE}
            echo 'Verifying image import...'
            sudo microk8s ctr images list | grep webgoat
            rm -f /tmp/${TAR_FILE}
            echo 'Image transfer completed!'
          "
    - task: CmdLine@2
      displayName: 'Deploy to Kubernetes'
      inputs:
        script: |
          IMAGE_NAME="docker.io/library/webgoat:$(Build.BuildId)"
          PUBLIC_IP="$(K8S_PUBLIC_IP)"
          WEBGOAT_PORT="$(WEBGOAT_NODEPORT)"
          WEBWOLF_PORT="$(WEBWOLF_NODEPORT)"

          cat > webgoat-deployment.yaml << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: webgoat
            namespace: default
            labels:
              app: webgoat
              version: "$(Build.BuildId)"
              deployed-by: azure-devops
              scanned-by: bridge-cli
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: webgoat
            template:
              metadata:
                labels:
                  app: webgoat
                  version: "$(Build.BuildId)"
              spec:
                containers:
                - name: webgoat
                  image: ${IMAGE_NAME}
                  imagePullPolicy: Never
                  ports:
                  - containerPort: 8080
                    name: webgoat
                    protocol: TCP
                  - containerPort: 9090
                    name: webwolf
                    protocol: TCP
                  resources:
                    requests:
                      memory: "1Gi"
                      cpu: "500m"
                    limits:
                      memory: "2Gi"
                      cpu: "1"
                  env:
                  - name: TZ
                    value: "America/New_York"
                  - name: WEBGOAT_HOST
                    value: "${PUBLIC_IP}"
                  - name: WEBWOLF_HOST
                    value: "${PUBLIC_IP}"
                  command: ["java"]
                  args: [
                    "-Duser.home=/home/webgoat",
                    "-Dfile.encoding=UTF-8",
                    "--add-opens", "java.base/java.lang=ALL-UNNAMED",
                    "--add-opens", "java.base/java.util=ALL-UNNAMED",
                    "--add-opens", "java.base/java.lang.reflect=ALL-UNNAMED",
                    "--add-opens", "java.base/java.text=ALL-UNNAMED",
                    "--add-opens", "java.desktop/java.beans=ALL-UNNAMED",
                    "--add-opens", "java.desktop/java.awt.font=ALL-UNNAMED",
                    "--add-opens", "java.base/sun.nio.ch=ALL-UNNAMED",
                    "--add-opens", "java.base/java.io=ALL-UNNAMED",
                    "-Drunning.in.docker=true",
                    "-jar", "webgoat.jar",
                    "--server.address", "0.0.0.0"
                  ]
                  livenessProbe:
                    httpGet:
                      path: /WebGoat/actuator/health
                      port: 8080
                      scheme: HTTP
                    initialDelaySeconds: 180
                    periodSeconds: 30
                    failureThreshold: 5
                    timeoutSeconds: 15
                  readinessProbe:
                    httpGet:
                      path: /WebGoat/actuator/health
                      port: 8080
                      scheme: HTTP
                    initialDelaySeconds: 120
                    periodSeconds: 15
                    failureThreshold: 5
                    timeoutSeconds: 15
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: webgoat-service
            namespace: default
            labels:
              app: webgoat
          spec:
            selector:
              app: webgoat
            ports:
            - port: 8080
              targetPort: 8080
              protocol: TCP
              name: webgoat
              nodePort: ${WEBGOAT_PORT}
            - port: 9090
              targetPort: 9090
              protocol: TCP
              name: webwolf
              nodePort: ${WEBWOLF_PORT}
            type: NodePort
          EOF

          scp -o StrictHostKeyChecking=no -i steve.pem webgoat-deployment.yaml ubuntu@$(K8S_SERVER_IP):/tmp/

          ssh -o StrictHostKeyChecking=no -i steve.pem ubuntu@$(K8S_SERVER_IP) "
            echo '=== Cleaning up existing deployment ==='
            kubectl delete deployment webgoat --ignore-not-found=true --grace-period=30
            kubectl delete service webgoat-service --ignore-not-found=true --grace-period=15
            sleep 15
            
            echo '=== Applying WebGoat Deployment ==='
            kubectl apply -f /tmp/webgoat-deployment.yaml
            
            echo '=== Monitoring Deployment Rollout ==='
            kubectl rollout status deployment/webgoat --timeout=300s || echo 'Deployment in progress...'
            
            echo '=== Current Status ==='
            kubectl get deployment webgoat
            kubectl get service webgoat-service
            kubectl get pods -l app=webgoat -o wide
            
            rm -f /tmp/webgoat-deployment.yaml
          "

- stage: Validation
  displayName: 'Stage 5: Validation'
  dependsOn:
  - DeployKubernetes
  jobs:
  - job: ValidationTest
    displayName: 'Validate Deployment'
    pool:
      name: 'Self-Hosted ADO Agent'
    steps:
    - task: DownloadSecureFile@1
      displayName: 'Download SSH Key'
      name: sshkey
      inputs:
        secureFile: 'steve-pem'
    - task: CmdLine@2
      displayName: 'Validate Deployment and Application'
      inputs:
        script: |
          echo "==============================================="
          echo "WEBGOAT DEPLOYMENT VALIDATION"
          echo "Bridge CLI Security Integration Pipeline"
          echo "==============================================="

          cp $(sshkey.secureFilePath) steve.pem
          chmod 400 steve.pem

          ssh -o StrictHostKeyChecking=no -i steve.pem ubuntu@$(K8S_SERVER_IP) "
            echo '=== Pod Status Check ==='
            kubectl get pods -l app=webgoat -o wide
            
            echo '=== Waiting for Pod Readiness ==='
            kubectl wait --for=condition=ready pod -l app=webgoat --timeout=300s || echo 'Pod readiness timeout'
            
            POD_NAME=\$(kubectl get pods -l app=webgoat -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo 'NO_POD')
            
            if [ \"\$POD_NAME\" = 'NO_POD' ]; then
                echo 'CRITICAL: No WebGoat pod found!'
                exit 1
            fi
            
            echo \"Working with pod: \$POD_NAME\"
            
            echo '=== Application Health Check ==='
            for attempt in {1..6}; do
              echo \"Health check attempt \$attempt/6...\"
              if kubectl exec \$POD_NAME -- curl -s -f http://localhost:8080/WebGoat/actuator/health >/dev/null 2>&1; then
                echo 'SUCCESS: WebGoat health endpoint responding!'
                break
              elif [ \$attempt -eq 6 ]; then
                echo 'WebGoat health endpoint not responding after 6 attempts'
              else
                echo 'WebGoat not ready, retrying in 30 seconds...'
                sleep 30
              fi
            done
          "

          echo ""
          echo "External connectivity test..."
          sleep 30
          if timeout 25 curl -s -I http://$(K8S_PUBLIC_IP):$(WEBGOAT_NODEPORT)/WebGoat/ 2>/dev/null | head -1 | grep -q "HTTP"; then
              echo "SUCCESS: WebGoat is externally accessible!"
          else
              echo "Note: WebGoat may need more time to fully start"
          fi

          echo ""
          echo "==============================================="
          echo "         PIPELINE COMPLETION SUMMARY"
          echo "==============================================="
          echo ""
          echo "✓ Stage 1: Build WebGoat - COMPLETED"
          echo "✓ Stage 2: Build Container - COMPLETED"  
          echo "✓ Stage 3: Security Scans (Bridge CLI) - COMPLETED"
          echo "✓ Stage 4: Kubernetes Deployment - COMPLETED"
          echo "✓ Stage 5: Validation - COMPLETED"
          echo ""
          echo "Security Scans Executed:"
          echo "  ✓ Black Duck SCA Source Analysis"
          echo "  ✓ Black Duck Container Analysis"
          echo "  ✓ Coverity SAST Analysis"
          echo ""
          echo "WebGoat Application Access:"
          echo "  Main: http://$(K8S_PUBLIC_IP):$(WEBGOAT_NODEPORT)/WebGoat/"
          echo "  Wolf: http://$(K8S_PUBLIC_IP):$(WEBWOLF_NODEPORT)/WebWolf/"
          echo "==============================================="
