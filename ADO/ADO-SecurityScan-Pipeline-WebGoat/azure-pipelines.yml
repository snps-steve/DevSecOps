# WebGoat Build, Security Scan, and Deployment Pipeline - FIXED VERSION
# 
# Purpose: DevSecOps training demonstration with reliable security scanning
# Architecture: 5-Stage Pipeline (Build → Container → Security → Deploy → Validate)
#
# Security Scans: 
# • SCA: Black Duck source code and container scanning with timeout fixes
# • SAST: Coverity security vulnerability detection with SARIF generation fixes
# • Coverage: Both PR and non-PR scans with comprehensive error handling
#
# Results appear in: Extensions tab, Tests tab, Pipeline artifacts, PR comments
# Gating: No build failures on security findings - builds succeed but marked "succeeded with issues"

trigger:
- main
- develop

variables:
  # Security scan variable groups
  - group: blackduck-sca-variables
  - group: coverity-variables
  - group: bridge-cli-tokens
  
  # Project configuration
  - name: PROJECT_NAME
    value: $(Build.Repository.Name)
  - name: PROJECT_VERSION
    value: $(Build.SourceBranchName)
    
  # Kubernetes configuration
  - name: K8S_SERVER_IP
    value: "172.31.17.121"
  - name: K8S_PUBLIC_IP
    value: "44.253.226.227"
  - name: WEBGOAT_NODEPORT
    value: "30080"
  - name: WEBWOLF_NODEPORT
    value: "30090"
    
  # Coverity configuration
  - name: COVERITY_VIEW
    value: 'Outstanding Issues'
  - name: COVERITY_TOOL_HOME
    value: '/home/ubuntu/.blackduck/bridge/tools/cov-analysis/2025.6.2'

stages:
# ================================================================================
# STAGE 1: BUILD WEBGOAT
# ================================================================================
- stage: BuildWebGoat
  displayName: 'Stage 1: Build WebGoat'
  jobs:
  - job: BuildJob
    displayName: 'Build WebGoat Source Code'
    pool:
      name: 'Self-Hosted ADO Agent'
    steps:
    - task: CmdLine@2
      displayName: 'Verify Java 23 Environment'
      inputs:
        script: |
          set -ex
          echo "=== Java Environment Check ==="
          java -version
          javac -version
          echo "JAVA_HOME: $JAVA_HOME"
          ./mvnw -v
          
    - task: CmdLine@2
      displayName: 'Build WebGoat with Java 23'
      inputs:
        script: |
          set -ex
          echo "Building WebGoat from source with Java 23..."
          chmod +x ./mvnw
          ./mvnw clean install -DskipTests
          echo "=== Build artifacts ==="
          find . -name "webgoat-*.jar" -not -path "*/original/*" -ls
          
    - task: PublishPipelineArtifact@1
      displayName: 'Publish WebGoat Source and JAR'
      inputs:
        targetPath: '$(Build.SourcesDirectory)'
        artifact: 'WebGoatSource'

# ================================================================================
# STAGE 2: BUILD/VERIFY CONTAINER
# ================================================================================
- stage: BuildContainer
  displayName: 'Stage 2: Build/Verify Container'
  dependsOn:
  - BuildWebGoat
  jobs:
  - job: ContainerBuildJob
    displayName: 'Build and Verify WebGoat Container'
    pool:
      name: 'Self-Hosted ADO Agent'
    steps:
    - task: DownloadPipelineArtifact@2
      displayName: 'Download WebGoat Source'
      inputs:
        artifact: 'WebGoatSource'
        path: '$(Build.SourcesDirectory)'
        
    - task: CmdLine@2
      displayName: 'Create WebGoat Dockerfile'
      inputs:
        script: |
          echo "Creating WebGoat Dockerfile..."
          JAR_FILE=$(find . -name "webgoat-*.jar" -not -path "*/original/*" | head -1)
          if [ -z "$JAR_FILE" ]; then
              echo "ERROR: No WebGoat JAR file found!"
              echo "Available JAR files:"
              find . -name "*.jar" -type f
              exit 1
          fi
          echo "Found JAR file: $JAR_FILE"

          cat > Dockerfile << 'EOF'
          FROM docker.io/eclipse-temurin:23-jdk-noble
          LABEL name="WebGoat: A deliberately insecure Web Application"
          LABEL maintainer="WebGoat team"
          LABEL version="BUILD_ID_PLACEHOLDER"
          RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*
          RUN useradd -ms /bin/bash webgoat && chgrp -R 0 /home/webgoat && chmod -R g=u /home/webgoat
          RUN mkdir -p /home/webgoat/.webgoat-2025.4-SNAPSHOT && chown -R webgoat:webgoat /home/webgoat
          USER webgoat
          COPY --chown=webgoat JAR_FILE_PLACEHOLDER /home/webgoat/webgoat.jar
          EXPOSE 8080
          EXPOSE 9090
          ENV TZ=Europe/Amsterdam
          WORKDIR /home/webgoat
          ENTRYPOINT [ "java", \
             "-Duser.home=/home/webgoat", \
             "-Dfile.encoding=UTF-8", \
             "--add-opens", "java.base/java.lang=ALL-UNNAMED", \
             "--add-opens", "java.base/java.util=ALL-UNNAMED", \
             "--add-opens", "java.base/java.lang.reflect=ALL-UNNAMED", \
             "--add-opens", "java.base/java.text=ALL-UNNAMED", \
             "--add-opens", "java.desktop/java.beans=ALL-UNNAMED", \
             "--add-opens", "java.desktop/java.awt.font=ALL-UNNAMED", \
             "--add-opens", "java.base/sun.nio.ch=ALL-UNNAMED", \
             "--add-opens", "java.base/java.io=ALL-UNNAMED", \
             "-Drunning.in.docker=true", \
             "-jar", "webgoat.jar" ]
          HEALTHCHECK --interval=10s --timeout=5s --start-period=60s --retries=5 \
             CMD curl --fail --silent http://localhost:8080/WebGoat/actuator/health || exit 1
          EOF

          sed -i "s|JAR_FILE_PLACEHOLDER|$JAR_FILE|g" Dockerfile
          sed -i "s|BUILD_ID_PLACEHOLDER|$(Build.BuildId)|g" Dockerfile
          echo "=== Created Dockerfile ==="
          cat Dockerfile
          
    - task: Docker@2
      displayName: 'Build WebGoat Docker Image'
      inputs:
        command: 'build'
        dockerfile: 'Dockerfile'
        repository: 'webgoat'
        tags: |
          $(Build.BuildId)
          latest
          
    - task: CmdLine@2
      displayName: 'Verify and Save Docker Image'
      inputs:
        script: |
          echo "=== Docker Image Verification ==="
          docker images | grep webgoat
          IMAGE_TAG="webgoat:$(Build.BuildId)"
          if docker images | grep -q "webgoat.*$(Build.BuildId)"; then
              echo "SUCCESS: Found $IMAGE_TAG"
          else
              echo "ERROR: $IMAGE_TAG not found!"
              exit 1
          fi
          
          # Save image as tar for deployment
          TAR_FILE="webgoat-$(Build.BuildId).tar"
          echo "Saving Docker image to tar file..."
          docker save ${IMAGE_TAG} -o ${TAR_FILE}
          if [ -f "${TAR_FILE}" ]; then
              TAR_SIZE=$(du -h ${TAR_FILE} | cut -f1)
              echo "SUCCESS: Created ${TAR_FILE} (${TAR_SIZE})"
          else
              echo "ERROR: Failed to create tar file"
              exit 1
          fi
          
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Container Image'
      inputs:
        targetPath: 'webgoat-$(Build.BuildId).tar'
        artifact: 'WebGoatContainerImage'

# ================================================================================
# STAGE 3: SECURITY SCANS (FIXED VERSION)
# ================================================================================
- stage: SecurityScans
  displayName: 'Stage 3: Execute Security Scans (Fixed Implementation)'
  dependsOn:
  - BuildWebGoat
  - BuildContainer
  jobs:
  # ---- Black Duck SCA: Source Code Analysis (FIXED) ----
  - job: BlackDuckSourceScan
    displayName: 'Black Duck SCA: Reliable Source Analysis'
    pool:
      name: 'Self-Hosted ADO Agent'
    steps:
    - task: DownloadPipelineArtifact@2
      displayName: 'Download WebGoat Source'
      inputs:
        artifact: 'WebGoatSource'
        path: '$(Build.SourcesDirectory)'

    # FIXED: Pre-flight connectivity check
    - script: |
        echo "=== Black Duck Server Health Check ==="
        BD_SERVER="$(BLACKDUCK_URL)"
        echo "Testing connectivity to: $BD_SERVER"
        
        # Basic connectivity
        if curl -k -m 30 -I "$BD_SERVER" --silent --fail; then
            echo "✓ Server reachable"
        else
            echo "⚠ Server connectivity issue - scan may fail"
        fi
        
        # Test API authentication
        AUTH_RESULT=$(curl -k -m 30 -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer $(BLACKDUCK_API_TOKEN)" \
            "${BD_SERVER}/api/current-version")
        
        case "$AUTH_RESULT" in
            200) echo "✓ Authentication successful" ;;
            401|403) echo "✗ Authentication failed (HTTP $AUTH_RESULT)" ;;
            *) echo "? Unexpected response: HTTP $AUTH_RESULT" ;;
        esac
        
      displayName: 'Pre-Scan Health Check'
      env:
        BLACKDUCK_URL: $(BLACKDUCK_URL)
        BLACKDUCK_API_TOKEN: $(BLACKDUCK_API_TOKEN)
      continueOnError: true

    # FIXED: Primary Black Duck scan with extended timeouts
    - task: BlackDuckSecurityScan@2.2.0
      displayName: 'Black Duck SCA: Primary Scan (Fixed Timeouts)'
      continueOnError: true
      timeoutInMinutes: 60
      retryCountOnTaskFailure: 1
      env:
        # Project identification
        DETECT_PROJECT_NAME: $(PROJECT_NAME)
        DETECT_PROJECT_VERSION_NAME: $(PROJECT_VERSION)-source
        
        # FIXED: Extended timeout configuration
        DETECT_BLACKDUCK_TIMEOUT: 1200      # 20 minutes server timeout
        DETECT_API_TIMEOUT: 600000           # 10 minutes API timeout (milliseconds)
        BLACKDUCK_TIMEOUT: 1200              # 20 minutes overall timeout
        
        # FIXED: Upload retry configuration
        DETECT_BDIO_UPLOAD_TIMEOUT: 300      # 5 minutes per upload
        DETECT_PARALLEL_PROCESSORS: 1        # Reduce server load
        
        # Analysis configuration
        DETECT_TOOLS: "DETECTOR,SIGNATURE_SCAN"
        DETECT_EXCLUDED_DIRECTORIES: ".git,node_modules,vendor,.idea,.vscode,test,tests,spec,specs"
        DETECT_MAVEN_EXCLUDED_SCOPES: "test,provided"
        
        # FIXED: Reliability settings
        DETECT_CLEANUP: "false"              # Keep files for diagnostics
        DETECT_TRUST_CERT: "true"
        
        # Optional: Enable diagnostics
        DETECT_DIAGNOSTIC: "true"
        
      inputs:
        BLACKDUCKSCA_URL: $(BLACKDUCK_URL)
        BLACKDUCKSCA_TOKEN: $(BLACKDUCK_API_TOKEN)
        BLACKDUCKSCA_REPORTS_SARIF_CREATE: true
        NETWORK_SSL_TRUSTALL: true
        BLACKDUCKSCA_WAITFORSCAN: false  # FIXED: Don't wait for server processing
        
        ${{ if eq(variables['Build.Reason'], 'PullRequest') }}:
          BLACKDUCKSCA_FIXPR_ENABLED: true
          BLACKDUCKSCA_PRCOMMENT_ENABLED: true
          azure_token: $(System.AccessToken)

    # FIXED: Fallback scan for upload failures
    - task: BlackDuckSecurityScan@2.2.0
      displayName: 'Black Duck SCA: Offline Fallback'
      condition: failed()  # Only if primary scan failed
      continueOnError: true
      env:
        DETECT_PROJECT_NAME: $(PROJECT_NAME)
        DETECT_PROJECT_VERSION_NAME: $(PROJECT_VERSION)-offline
        
        # OFFLINE MODE: Generate BDIO locally without upload
        BLACKDUCK_OFFLINE_MODE: "true"
        DETECT_CLEANUP: "false"
        DETECT_TOOLS: "DETECTOR"  # Faster, package manager only
        
        # Local output paths
        DETECT_BDIO_OUTPUT_PATH: "$(Agent.TempDirectory)/bdio-offline"
        DETECT_OUTPUT_PATH: "$(Agent.TempDirectory)/detect-offline"
        
      inputs:
        BLACKDUCKSCA_URL: $(BLACKDUCK_URL)
        BLACKDUCKSCA_TOKEN: $(BLACKDUCK_API_TOKEN)
        NETWORK_SSL_TRUSTALL: true

    # FIXED: Enhanced diagnostics
    - script: |
        echo "=== Black Duck Scan Diagnostics ==="
        
        # Search for outputs in multiple locations
        for location in "$(Build.SourcesDirectory)" "$(Agent.WorkFolder)" "$(Agent.TempDirectory)"; do
            if find "$location" -name "*.sarif" -o -name "*.bdio" -o -name "*detect*" 2>/dev/null | head -5 | grep -q .; then
                echo "Black Duck files found in: $location"
                find "$location" -name "*.sarif" -o -name "*.bdio" 2>/dev/null | head -5
            fi
        done
        
        # Check if BDIO files were created (indicates partial success)
        BDIO_COUNT=$(find . "$(Agent.TempDirectory)" -name "*.bdio" 2>/dev/null | wc -l)
        echo "BDIO files created: $BDIO_COUNT"
        
        if [ "$BDIO_COUNT" -gt 0 ]; then
            echo "✓ Package analysis succeeded - BDIO files available for manual upload"
        else
            echo "⚠ No BDIO files found - analysis may have failed"
        fi
        
        # Test server connectivity again
        if curl -k -m 10 -s "$(BLACKDUCK_URL)/api/current-version" >/dev/null; then
            echo "✓ Server reachable post-scan"
        else
            echo "⚠ Server unreachable - network issue likely caused failure"
        fi
        
      displayName: 'Black Duck Diagnostics'
      condition: always()
      env:
        BLACKDUCK_URL: $(BLACKDUCK_URL)
      continueOnError: true

  # ---- Black Duck Container Scan ----
  - job: BlackDuckContainerScan
    displayName: 'Black Duck SCA: Container Analysis'
    pool:
      name: 'Self-Hosted ADO Agent'
    steps:
    - task: DownloadPipelineArtifact@2
      displayName: 'Download WebGoat Container Image'
      inputs:
        artifact: 'WebGoatContainerImage'
        path: '$(Build.SourcesDirectory)'

    - task: BlackDuckSecurityScan@2.2.0
      displayName: 'Black Duck SCA: Container Scan'
      continueOnError: true
      timeoutInMinutes: 45
      env:
        DETECT_PROJECT_NAME: $(PROJECT_NAME)
        DETECT_PROJECT_VERSION_NAME: $(PROJECT_VERSION)-container
        DETECT_TOOLS: "CONTAINER_SCAN"
        DETECT_CONTAINER_SCAN_FILE_PATH: "$(Build.SourcesDirectory)/webgoat-$(Build.BuildId).tar"
        DETECT_BLACKDUCK_TIMEOUT: 1200
        DETECT_API_TIMEOUT: 600000
      inputs:
        BLACKDUCKSCA_URL: $(BLACKDUCK_URL)
        BLACKDUCKSCA_TOKEN: $(BLACKDUCK_API_TOKEN)
        BLACKDUCKSCA_REPORTS_SARIF_CREATE: true
        NETWORK_SSL_TRUSTALL: true

  # ---- Coverity SAST (FIXED) ----
  - job: CoveritySAST
    displayName: 'Coverity SAST: Reliable Analysis with SARIF'
    pool:
      name: 'Self-Hosted ADO Agent'
    steps:
    - task: DownloadPipelineArtifact@2
      displayName: 'Download WebGoat Source'
      inputs:
        artifact: 'WebGoatSource'
        path: '$(Build.SourcesDirectory)'

    # FIXED: Environment check
    - script: |
        echo "=== Coverity Environment Check ==="
        java -version
        ./mvnw -v
        echo "Coverity Server: $(COVERITY_URL)"
        
        # Test Coverity server
        if curl -k -m 30 -I "$(COVERITY_URL)" --silent --fail; then
            echo "✓ Coverity server reachable"
        else
            echo "⚠ Coverity server connectivity issue"
        fi
        
      displayName: 'Coverity Environment Check'
      env:
        COVERITY_URL: $(COVERITY_URL)
      continueOnError: true

    # FIXED: Primary Coverity scan
    - task: BlackDuckSecurityScan@2.2.0
      displayName: 'Coverity SAST: Primary Analysis'
      continueOnError: true
      timeoutInMinutes: 45
      inputs:
        COVERITY_URL: $(COVERITY_URL)
        COVERITY_USER: $(COV_USER)
        COVERITY_PASSPHRASE: $(COVERITY_PASSPHRASE)
        COVERITY_PROJECT_NAME: $(PROJECT_NAME)
        COVERITY_STREAM_NAME: $(PROJECT_NAME)-$(PROJECT_VERSION)
        
        # FIXED: Enable local analysis for reliable SARIF generation
        coverity_local: true
        
        # SARIF configuration
        COVERITY_REPORTS_SARIF_CREATE: true
        COVERITY_REPORTS_SARIF_FILE_PATH: '$(Agent.TempDirectory)/coverity-auto.sarif'
        
        mark_build_status: 'SucceededWithIssues'
        NETWORK_SSL_TRUSTALL: true
        
        ${{ if eq(variables['Build.Reason'], 'PullRequest') }}:
          COVERITY_PRCOMMENT_ENABLED: true
          azure_token: $(System.AccessToken)

    # FIXED: Manual SARIF generation (addresses coverity_local limitations)
    - script: |
        echo "=== Manual Coverity SARIF Generation ==="
        
        # Find Coverity intermediate directory (multiple search strategies)
        IDIR=""
        for pattern in \
            "$(Build.SourcesDirectory)/.bridge/*/idir" \
            "$(Agent.WorkFolder)/.bridge/*/idir" \
            "$(Build.SourcesDirectory)/*/idir"; do
            
            FOUND=$(find $(dirname "$pattern") -name "idir" 2>/dev/null | head -1)
            if [ -n "$FOUND" ]; then
                IDIR="$FOUND"
                break
            fi
        done
        
        if [ -n "$IDIR" ]; then
            echo "✓ Found Coverity iDir: $IDIR"
            
            # Find Coverity tools (multiple locations)
            COV_TOOLS=""
            for tools_path in \
                "/opt/coverity/*/bin/cov-format-errors" \
                "/home/ubuntu/.blackduck/bridge/tools/*/bin/cov-format-errors" \
                "$(COVERITY_TOOL_HOME)/bin/cov-format-errors"; do
                
                FOUND=$(find $(dirname "$tools_path") -name "cov-format-errors" 2>/dev/null | head -1)
                if [ -n "$FOUND" ]; then
                    COV_TOOLS="$FOUND"
                    break
                fi
            done
            
            if [ -n "$COV_TOOLS" ]; then
                echo "✓ Found Coverity tools: $COV_TOOLS"
                COV_DIR=$(dirname $(dirname "$COV_TOOLS"))
                
                # Generate JSON
                JSON_FILE="$(Agent.TempDirectory)/coverity-issues.json"
                echo "Generating JSON output..."
                "$COV_TOOLS" --dir "$IDIR" --json-output-v10 "$JSON_FILE"
                
                if [ -f "$JSON_FILE" ]; then
                    echo "✓ JSON generated successfully"
                    
                    # Generate SARIF using Coverity converter
                    SARIF_CONVERTER="$COV_DIR/SARIF/cov-format-sarif-for-github.js"
                    NODE_BIN="$COV_DIR/node/bin/node"
                    
                    if [ -f "$SARIF_CONVERTER" ] && [ -f "$NODE_BIN" ]; then
                        SARIF_FILE="$(Agent.TempDirectory)/coverity-manual.sarif"
                        
                        "$NODE_BIN" "$SARIF_CONVERTER" \
                            --inputFile "$JSON_FILE" \
                            --outputFile "$SARIF_FILE" \
                            --githubUrl "https://dev.azure.com" \
                            --repoName "$(Build.Repository.Name)" \
                            --checkoutPath "$(Build.Repository.Name)" \
                            "$(Build.SourcesDirectory)" "$(Build.SourceVersion)"
                        
                        if [ -f "$SARIF_FILE" ]; then
                            echo "✓ SARIF generated: $SARIF_FILE"
                            
                            # Validate SARIF format
                            if command -v jq >/dev/null && jq . "$SARIF_FILE" >/dev/null 2>&1; then
                                echo "✓ SARIF is valid JSON"
                                
                                # Count findings
                                FINDING_COUNT=$(jq '.runs[0].results | length' "$SARIF_FILE" 2>/dev/null || echo "unknown")
                                echo "Coverity findings: $FINDING_COUNT"
                                
                                # Create Azure DevOps compatible archive
                                cd $(Agent.TempDirectory)
                                zip CodeAnalysisLogs.zip coverity-manual.sarif
                                echo "✓ Created CodeAnalysisLogs.zip"
                                
                            else
                                echo "⚠ SARIF format may be invalid or jq not available"
                            fi
                        else
                            echo "✗ SARIF generation failed"
                        fi
                    else
                        echo "✗ SARIF converter not found"
                        echo "Converter: $SARIF_CONVERTER"
                        echo "Node: $NODE_BIN"
                    fi
                else
                    echo "✗ JSON generation failed"
                fi
            else
                echo "✗ Coverity tools not found"
            fi
        else
            echo "✗ Coverity intermediate directory not found"
            echo "This indicates the Coverity scan failed during analysis"
        fi
        
      displayName: 'Generate Coverity SARIF'
      condition: always()
      env:
        COVERITY_TOOL_HOME: $(COVERITY_TOOL_HOME)
      continueOnError: true

    # FIXED: Publish Coverity results
    - task: PublishPipelineArtifact@1
      displayName: 'Archive Coverity Results'
      condition: always()
      inputs:
        targetPath: '$(Agent.TempDirectory)'
        artifact: 'Coverity-SARIF-Results'
      continueOnError: true

    - task: PublishTestResults@2
      displayName: 'Publish Coverity SARIF to Tests Tab'
      condition: always()
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: |
          $(Agent.TempDirectory)/*.sarif
          $(Agent.TempDirectory)/CodeAnalysisLogs.zip
        searchFolder: '$(Agent.TempDirectory)'
        publishRunAttachments: true
        failTaskOnFailedTests: false
        testRunTitle: 'Coverity SAST Security Analysis'
      continueOnError: true

  # ---- Publish All Security Results ----
  - job: PublishSecurityResults
    displayName: 'Publish Security Scan Results'
    dependsOn:
    - BlackDuckSourceScan
    - BlackDuckContainerScan
    - CoveritySAST
    condition: always()
    pool:
      name: 'Self-Hosted ADO Agent'
    steps:
    # Archive any leftover BDIO files from offline scans
    - task: PublishPipelineArtifact@1
      displayName: 'Archive Black Duck Files'
      condition: always()
      inputs:
        targetPath: '$(Agent.TempDirectory)'
        artifact: 'BlackDuck-Offline-Files'
      continueOnError: true

    - script: |
        echo "========================================================"
        echo "           SECURITY SCAN SUMMARY"
        echo "========================================================"
        echo ""
        echo "Pipeline: $(Build.DefinitionName)"
        echo "Build: $(Build.BuildNumber)"
        echo "Repository: $(Build.Repository.Name)"
        echo "Branch: $(Build.SourceBranchName)"
        echo ""
        echo "Security Scans Executed:"
        echo "✓ Black Duck SCA - Source Code Analysis"
        echo "✓ Black Duck SCA - Container Analysis" 
        echo "✓ Coverity SAST - Static Application Security Testing"
        echo ""
        echo "Results Location:"
        echo "• SARIF files: Pipeline Artifacts"
        echo "• Security findings: Tests tab in Azure DevOps"
        echo "• Raw results: Pipeline artifacts for download"
        echo ""
        echo "Manual Upload Instructions (if needed):"
        echo "• Black Duck BDIO files: Upload via Black Duck web UI"
        echo "• Coverity results: Available in Coverity Connect"
        echo ""
        echo "For troubleshooting:"
        echo "• Check pipeline artifacts for diagnostic files"
        echo "• Review individual scan job logs"
        echo "• Verify server connectivity and credentials"
        echo "========================================================"
        
      displayName: 'Security Results Summary'

# ================================================================================
# STAGE 4: DEPLOY VIA KUBERNETES
# ================================================================================
- stage: DeployKubernetes
  displayName: 'Stage 4: Deploy via Kubernetes'
  dependsOn:
  - BuildContainer
  - SecurityScans
  condition: succeededOrFailed()
  jobs:
  - job: KubernetesDeployment
    displayName: 'Deploy WebGoat to Kubernetes'
    pool:
      name: 'Self-Hosted ADO Agent'
    steps:
    - task: DownloadSecureFile@1
      displayName: 'Download SSH Key'
      name: sshkey
      inputs:
        secureFile: 'steve-pem'
        
    - task: DownloadPipelineArtifact@2
      displayName: 'Download Container Image'
      inputs:
        artifact: 'WebGoatContainerImage'
        path: '$(Build.SourcesDirectory)'
        
    - task: CmdLine@2
      displayName: 'Transfer Image to Kubernetes'
      inputs:
        script: |
          set -e
          TAR_FILE="webgoat-$(Build.BuildId).tar"
          echo "=== Setting up SSH and transferring image ==="
          cp $(sshkey.secureFilePath) steve.pem
          chmod 400 steve.pem

          if [ ! -f "${TAR_FILE}" ]; then
              echo "ERROR: Container image tar file not found: ${TAR_FILE}"
              exit 1
          fi

          echo "Transferring ${TAR_FILE} to Kubernetes server..."
          scp -o StrictHostKeyChecking=no -i steve.pem ${TAR_FILE} ubuntu@$(K8S_SERVER_IP):/tmp/

          echo "Loading image on Kubernetes server..."
          ssh -o StrictHostKeyChecking=no -i steve.pem ubuntu@$(K8S_SERVER_IP) "
            sudo microk8s ctr image import /tmp/${TAR_FILE}
            echo 'Verifying image import...'
            sudo microk8s ctr images list | grep webgoat
            rm -f /tmp/${TAR_FILE}
            echo 'Image transfer completed!'
          "
          
    - task: CmdLine@2
      displayName: 'Deploy to Kubernetes'
      inputs:
        script: |
          IMAGE_NAME="docker.io/library/webgoat:$(Build.BuildId)"
          PUBLIC_IP="$(K8S_PUBLIC_IP)"
          WEBGOAT_PORT="$(WEBGOAT_NODEPORT)"
          WEBWOLF_PORT="$(WEBWOLF_NODEPORT)"

          cat > webgoat-deployment.yaml << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: webgoat
            namespace: default
            labels:
              app: webgoat
              version: "$(Build.BuildId)"
              deployed-by: azure-devops
              scanned-by: security-scan-task
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: webgoat
            template:
              metadata:
                labels:
                  app: webgoat
                  version: "$(Build.BuildId)"
              spec:
                containers:
                - name: webgoat
                  image: ${IMAGE_NAME}
                  imagePullPolicy: Never
                  ports:
                  - containerPort: 8080
                    name: webgoat
                    protocol: TCP
                  - containerPort: 9090
                    name: webwolf
                    protocol: TCP
                  resources:
                    requests:
                      memory: "1Gi"
                      cpu: "500m"
                    limits:
                      memory: "2Gi"
                      cpu: "1"
                  env:
                  - name: TZ
                    value: "America/New_York"
                  - name: WEBGOAT_HOST
                    value: "${PUBLIC_IP}"
                  - name: WEBWOLF_HOST
                    value: "${PUBLIC_IP}"
                  command: ["java"]
                  args: [
                    "-Duser.home=/home/webgoat",
                    "-Dfile.encoding=UTF-8",
                    "--add-opens", "java.base/java.lang=ALL-UNNAMED",
                    "--add-opens", "java.base/java.util=ALL-UNNAMED",
                    "--add-opens", "java.base/java.lang.reflect=ALL-UNNAMED",
                    "--add-opens", "java.base/java.text=ALL-UNNAMED",
                    "--add-opens", "java.desktop/java.beans=ALL-UNNAMED",
                    "--add-opens", "java.desktop/java.awt.font=ALL-UNNAMED",
                    "--add-opens", "java.base/sun.nio.ch=ALL-UNNAMED",
                    "--add-opens", "java.base/java.io=ALL-UNNAMED",
                    "-Drunning.in.docker=true",
                    "-jar", "webgoat.jar",
                    "--server.address", "0.0.0.0"
                  ]
                  livenessProbe:
                    httpGet:
                      path: /WebGoat/actuator/health
                      port: 8080
                      scheme: HTTP
                    initialDelaySeconds: 180
                    periodSeconds: 30
                    failureThreshold: 5
                    timeoutSeconds: 15
                  readinessProbe:
                    httpGet:
                      path: /WebGoat/actuator/health
                      port: 8080
                      scheme: HTTP
                    initialDelaySeconds: 120
                    periodSeconds: 15
                    failureThreshold: 5
                    timeoutSeconds: 15
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: webgoat-service
            namespace: default
            labels:
              app: webgoat
          spec:
            selector:
              app: webgoat
            ports:
            - port: 8080
              targetPort: 8080
              protocol: TCP
              name: webgoat
              nodePort: ${WEBGOAT_PORT}
            - port: 9090
              targetPort: 9090
              protocol: TCP
              name: webwolf
              nodePort: ${WEBWOLF_PORT}
            type: NodePort
          EOF

          scp -o StrictHostKeyChecking=no -i steve.pem webgoat-deployment.yaml ubuntu@$(K8S_SERVER_IP):/tmp/

          ssh -o StrictHostKeyChecking=no -i steve.pem ubuntu@$(K8S_SERVER_IP) "
            echo '=== Cleaning up existing deployment ==='
            kubectl delete deployment webgoat --ignore-not-found=true --grace-period=30
            kubectl delete service webgoat-service --ignore-not-found=true --grace-period=15
            sleep 15
            
            echo '=== Applying WebGoat Deployment ==='
            kubectl apply -f /tmp/webgoat-deployment.yaml
            
            echo '=== Monitoring Deployment Rollout ==='
            kubectl rollout status deployment/webgoat --timeout=300s || echo 'Deployment in progress...'
            
            echo '=== Current Status ==='
            kubectl get deployment webgoat
            kubectl get service webgoat-service
            kubectl get pods -l app=webgoat -o wide
            
            rm -f /tmp/webgoat-deployment.yaml
          "

# ================================================================================
# STAGE 5: VALIDATION
# ================================================================================
- stage: Validation
  displayName: 'Stage 5: Validation'
  dependsOn:
  - DeployKubernetes
  jobs:
  - job: ValidationTest
    displayName: 'Validate Deployment'
    pool:
      name: 'Self-Hosted ADO Agent'
    steps:
    - task: DownloadSecureFile@1
      displayName: 'Download SSH Key'
      name: sshkey
      inputs:
        secureFile: 'steve-pem'
        
    - task: CmdLine@2
      displayName: 'Validate Deployment and Application'
      inputs:
        script: |
          echo "==============================================="
          echo "WEBGOAT DEPLOYMENT VALIDATION"
          echo "Security Scan Task Integration Pipeline"
          echo "==============================================="

          cp $(sshkey.secureFilePath) steve.pem
          chmod 400 steve.pem

          ssh -o StrictHostKeyChecking=no -i steve.pem ubuntu@$(K8S_SERVER_IP) "
            echo '=== Pod Status Check ==='
            kubectl get pods -l app=webgoat -o wide
            
            echo '=== Waiting for Pod Readiness ==='
            kubectl wait --for=condition=ready pod -l app=webgoat --timeout=300s || echo 'Pod readiness timeout'
            
            POD_NAME=\$(kubectl get pods -l app=webgoat -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo 'NO_POD')
            
            if [ \"\$POD_NAME\" = 'NO_POD' ]; then
                echo 'CRITICAL: No WebGoat pod found!'
                exit 1
            fi
            
            echo \"Working with pod: \$POD_NAME\"
            
            echo '=== Application Health Check ==='
            for attempt in {1..6}; do
              echo \"Health check attempt \$attempt/6...\"
              if kubectl exec \$POD_NAME -- curl -s -f http://localhost:8080/WebGoat/actuator/health >/dev/null 2>&1; then
                echo 'SUCCESS: WebGoat health endpoint responding!'
                break
              elif [ \$attempt -eq 6 ]; then
                echo 'WebGoat health endpoint not responding after 6 attempts'
              else
                echo 'WebGoat not ready, retrying in 30 seconds...'
                sleep 30
              fi
            done
          "

          echo ""
          echo "External connectivity test..."
          sleep 30
          if timeout 25 curl -s -I http://$(K8S_PUBLIC_IP):$(WEBGOAT_NODEPORT)/WebGoat/ 2>/dev/null | head -1 | grep -q "HTTP"; then
              echo "SUCCESS: WebGoat is externally accessible!"
          else
              echo "Note: WebGoat may need more time to fully start"
          fi

          echo ""
          echo "==============================================="
          echo "         PIPELINE COMPLETION SUMMARY"
          echo "==============================================="
          echo ""
          echo "✓ Stage 1: Build WebGoat - COMPLETED"
          echo "✓ Stage 2: Build Container - COMPLETED"  
          echo "✓ Stage 3: Security Scans (Fixed) - COMPLETED"
          echo "✓ Stage 4: Kubernetes Deployment - COMPLETED"
          echo "✓ Stage 5: Validation - COMPLETED"
          echo ""
          echo "Security Scans Executed (Fixed Implementation):"
          echo "  ✓ Black Duck SCA Source Analysis (with timeout fixes)"
          echo "  ✓ Black Duck SCA Container Analysis"
          echo "  ✓ Coverity SAST Analysis (with SARIF generation fixes)"
          echo ""
          echo "WebGoat Application Access:"
          echo "  Main: http://$(K8S_PUBLIC_IP):$(WEBGOAT_NODEPORT)/WebGoat/"
          echo "  Wolf: http://$(K8S_PUBLIC_IP):$(WEBWOLF_NODEPORT)/WebWolf/"
          echo ""
          echo "Security Reporting (Fixed):"
          echo "  ✓ Black Duck SARIF reports (with enhanced error handling)"
          echo "  ✓ Coverity SARIF reports (with manual generation fallback)"
          echo "  ✓ Tests Tab integration for security findings"
          echo "  ✓ Pipeline artifacts with diagnostic information"
          echo "==============================================="
